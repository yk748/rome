# Best shot comparison:
# CV_rome
cv_rome <- cv.rome(x=x,y=y,FUN="rome.adaptive",delta=0.5)
fit_cv_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=cv_rome$lambda_min,delta=0.5,
adapt=FALSE,trace=FALSE)
# CV_hqreg
cv_hqreg <- cv.hqreg(X=x,y=y,FUN="hqreg_raw",gamma=0.5,intercept=FALSE)
fit_cv_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=c(cv_hqreg$lambda.min,0.5*cv_hqreg$lambda.min),
gamma=0.5,
intercept=FALSE,message=FALSE)
# cv_ILAMM
cv_ILAMM <- cvNcvxHuberReg(X=x,Y=y,tSeq=0.5,nfolds=10,intercept=FALSE, penalty="Lasso")
fit_cv_ILAMM <- ncvxHuberReg(X=x,Y=y,lambda=cv_ILAMM$lambdaMin,
tau=0.5, intercept=FALSE, penalty="Lasso")
c(norm(fit_cv_rome$beta-b,"2")/norm(b,"2"),
norm(fit_cv_hqreg$beta[,1]-b,"2")/norm(b,"2"),
norm(fit_cv_ILAMM$beta[-1]-b,"2")/norm(b,"2"))
########################################################################
# Data generating process:
n <- 100
p <- 500
# ---------------------------------------------------------- #
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
# ---------------------------------------------------------- #
# type 4:
rho1 <- 0.2; rho2 <- 0.8; v <- 1
sigma1 <- matrix(NA,p/2,p/2)
for (j in 1:p/2){
for (k in 1:p/2){
sigma1[j,k] <-  rho1^(abs(j-k))
}
}
sigma2 <- matrix(NA,p/2,p/2)
for (j in 1:p/2){
for (k in 1:p/2){
sigma2[j,k] <-  rho2^(abs(j-k))
}
}
x <- cbind(rmvt(n,sigma=sigma1),
rmvnorm(n,mean=rep(0,p/2),sigma=sigma2))
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
e <- rnorm(n,0,1)
y <- x %*% b + e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
lambdas <- mapply(j=0:99,function(j)lambda_max*exp((log(0.05)/(100 - 1)))^j)
# ---------------------------------------------------------- #
# rome:
start_t_rome <- proc.time()
fit_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=lambdas,delta=gamma,
adapt=FALSE)
end_t_rome <- proc.time()
# ---------------------------------------------------------- #
# hqreg:
start_t_hqreg <- proc.time()
fit_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=lambdas/gamma,gamma=gamma,
intercept=FALSE,screen="ASR")
end_t_hqreg <- proc.time()
# ---------------------------------------------------------- #
# ILAMM:
beta_ILAMM <- matrix(NA,p,length(lambdas))
start_t_ILAMM <- proc.time()
for (l in 1:100){
# Fit Huber-SCAD without intercept
fit <- ncvxHuberReg(X=x, Y=y, lambda=lambdas[l], tau=gamma, intercept=FALSE, penalty="Lasso")
beta_ILAMM[,l] <- fit$beta[-1]
# cat(l,"th iteration done.\n")
}
end_t_ILAMM <- proc.time()
# ---------------------------------------------------------- #
# paths:
plot.ts(cbind(mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))) )
# time:
c(c(end_t_rome - start_t_rome)[3],
c(end_t_hqreg - start_t_hqreg)[3],
c(end_t_ILAMM - start_t_ILAMM)[3])
# ---------------------------------------------------------- #
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
lambdas <- mapply(j=0:99,function(j)lambda_max*exp((log(0.05)/(100 - 1)))^j)
# ---------------------------------------------------------- #
# rome:
start_t_rome <- proc.time()
fit_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=lambdas,delta=gamma,
adapt=FALSE)
end_t_rome <- proc.time()
# ---------------------------------------------------------- #
# hqreg:
start_t_hqreg <- proc.time()
fit_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=lambdas/gamma,gamma=gamma,
intercept=FALSE,screen="ASR")
end_t_hqreg <- proc.time()
# ---------------------------------------------------------- #
# ILAMM:
beta_ILAMM <- matrix(NA,p,length(lambdas))
start_t_ILAMM <- proc.time()
for (l in 1:100){
# Fit Huber-SCAD without intercept
fit <- ncvxHuberReg(X=x, Y=y, lambda=lambdas[l], tau=gamma, intercept=FALSE, penalty="Lasso")
beta_ILAMM[,l] <- fit$beta[-1]
# cat(l,"th iteration done.\n")
}
end_t_ILAMM <- proc.time()
# ---------------------------------------------------------- #
# paths:
plot.ts(cbind(mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))) )
# time:
c(c(end_t_rome - start_t_rome)[3],
c(end_t_hqreg - start_t_hqreg)[3],
c(end_t_ILAMM - start_t_ILAMM)[3])
########################################################################
# Best shot comparison:
# CV_rome
cv_rome <- cv.rome(x=x,y=y,FUN="rome.adaptive",delta=0.5)
fit_cv_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=cv_rome$lambda_min,delta=0.5,
adapt=FALSE,trace=FALSE)
# CV_hqreg
cv_hqreg <- cv.hqreg(X=x,y=y,FUN="hqreg_raw",gamma=0.5,intercept=FALSE)
fit_cv_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=c(cv_hqreg$lambda.min,0.5*cv_hqreg$lambda.min),
gamma=0.5,
intercept=FALSE,message=FALSE)
# cv_ILAMM
cv_ILAMM <- cvNcvxHuberReg(X=x,Y=y,tSeq=0.5,nfolds=10,intercept=FALSE, penalty="Lasso")
fit_cv_ILAMM <- ncvxHuberReg(X=x,Y=y,lambda=cv_ILAMM$lambdaMin,
tau=0.5, intercept=FALSE, penalty="Lasso")
c(norm(fit_cv_rome$beta-b,"2")/norm(b,"2"),
norm(fit_cv_hqreg$beta[,1]-b,"2")/norm(b,"2"),
norm(fit_cv_ILAMM$beta[-1]-b,"2")/norm(b,"2"))
########################################################################
# Data generating process:
n <- 100
p <- 200
# ---------------------------------------------------------- #
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
t(b) %*% t(x) %*% x %*% b
t(b) %*% t(x) %*% x %*% b / var(e)
k <- t(b) %*% t(x) %*% x %*% b / var(e)
k
y <- x %*% b + sqrt(k)*e
t(b) %*% t(x) %*% x %*% b / (k*var(e))
t(b) %*% t(x) %*% x %*% b / var(e)
k <- t(b) %*% t(x) %*% x %*% b / var(e)
y <- x %*% b + sqrt(k)*e
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
k <- t(b) %*% t(x) %*% x %*% b / var(e)
y <- x %*% b + rep(sqrt(k),n)*e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
lambdas <- mapply(j=0:99,function(j)lambda_max*exp((log(0.05)/(100 - 1)))^j)
# ---------------------------------------------------------- #
# rome:
start_t_rome <- proc.time()
fit_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=lambdas,delta=gamma,
adapt=FALSE)
end_t_rome <- proc.time()
# ---------------------------------------------------------- #
# hqreg:
start_t_hqreg <- proc.time()
fit_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=lambdas/gamma,gamma=gamma,
intercept=FALSE,screen="ASR")
end_t_hqreg <- proc.time()
# ---------------------------------------------------------- #
# ILAMM:
beta_ILAMM <- matrix(NA,p,length(lambdas))
start_t_ILAMM <- proc.time()
for (l in 1:100){
# Fit Huber-SCAD without intercept
fit <- ncvxHuberReg(X=x, Y=y, lambda=lambdas[l], tau=gamma, intercept=FALSE, penalty="Lasso")
beta_ILAMM[,l] <- fit$beta[-1]
# cat(l,"th iteration done.\n")
}
end_t_ILAMM <- proc.time()
# ---------------------------------------------------------- #
# paths:
plot.ts(cbind(mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))) )
# time:
c(c(end_t_rome - start_t_rome)[3],
c(end_t_hqreg - start_t_hqreg)[3],
c(end_t_ILAMM - start_t_ILAMM)[3])
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
lambdas <- mapply(j=0:99,function(j)lambda_max*exp((log(0.05)/(100 - 1)))^j)
# ---------------------------------------------------------- #
# rome:
start_t_rome <- proc.time()
fit_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=lambdas,delta=gamma,
adapt=FALSE)
end_t_rome <- proc.time()
# ---------------------------------------------------------- #
# hqreg:
start_t_hqreg <- proc.time()
fit_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=lambdas/gamma,gamma=gamma,
intercept=FALSE,screen="ASR")
end_t_hqreg <- proc.time()
# ---------------------------------------------------------- #
# ILAMM:
beta_ILAMM <- matrix(NA,p,length(lambdas))
start_t_ILAMM <- proc.time()
for (l in 1:100){
# Fit Huber-SCAD without intercept
fit <- ncvxHuberReg(X=x, Y=y, lambda=lambdas[l], tau=gamma, intercept=FALSE, penalty="Lasso")
beta_ILAMM[,l] <- fit$beta[-1]
# cat(l,"th iteration done.\n")
}
end_t_ILAMM <- proc.time()
# ---------------------------------------------------------- #
# paths:
plot.ts(cbind(mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))) )
# time:
c(c(end_t_rome - start_t_rome)[3],
c(end_t_hqreg - start_t_hqreg)[3],
c(end_t_ILAMM - start_t_ILAMM)[3])
########################################################################
# Best shot comparison:
# CV_rome
cv_rome <- cv.rome(x=x,y=y,FUN="rome.adaptive",delta=0.5)
fit_cv_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=cv_rome$lambda_min,delta=0.5,
adapt=FALSE,trace=FALSE)
# CV_hqreg
cv_hqreg <- cv.hqreg(X=x,y=y,FUN="hqreg_raw",gamma=0.5,intercept=FALSE)
fit_cv_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=c(cv_hqreg$lambda.min,0.5*cv_hqreg$lambda.min),
gamma=0.5,
intercept=FALSE,message=FALSE)
# cv_ILAMM
cv_ILAMM <- cvNcvxHuberReg(X=x,Y=y,tSeq=0.5,nfolds=10,intercept=FALSE, penalty="Lasso")
fit_cv_ILAMM <- ncvxHuberReg(X=x,Y=y,lambda=cv_ILAMM$lambdaMin,
tau=0.5, intercept=FALSE, penalty="Lasso")
c(norm(fit_cv_rome$beta-b,"2")/norm(b,"2"),
norm(fit_cv_hqreg$beta[,1]-b,"2")/norm(b,"2"),
norm(fit_cv_ILAMM$beta[-1]-b,"2")/norm(b,"2"))
# CV_rome
cv_rome <- cv.rome(x=x,y=y,FUN="rome.adaptive",delta=1.5)
fit_cv_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=cv_rome$lambda_min,delta=1.5,
adapt=FALSE,trace=FALSE)
# CV_hqreg
cv_hqreg <- cv.hqreg(X=x,y=y,FUN="hqreg_raw",gamma=1.5,intercept=FALSE)
fit_cv_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=c(cv_hqreg$lambda.min,0.9*cv_hqreg$lambda.min),
gamma=1.5,
intercept=FALSE,message=FALSE)
# cv_ILAMM
cv_ILAMM <- cvNcvxHuberReg(X=x,Y=y,tSeq=1.5,nfolds=10,intercept=FALSE, penalty="Lasso")
fit_cv_ILAMM <- ncvxHuberReg(X=x,Y=y,lambda=cv_ILAMM$lambdaMin,
tau=1.5, intercept=FALSE, penalty="Lasso")
c(norm(fit_cv_rome$beta-b,"2")/norm(b,"2"),
norm(fit_cv_hqreg$beta[,1]-b,"2")/norm(b,"2"),
norm(fit_cv_ILAMM$beta[-1]-b,"2")/norm(b,"2"))
# ---------------------------------------------------------- #
# type 4:
rho1 <- 0.2; rho2 <- 0.8; v <- 1
sigma1 <- matrix(NA,p/2,p/2)
for (j in 1:p/2){
for (k in 1:p/2){
sigma1[j,k] <-  rho1^(abs(j-k))
}
}
sigma2 <- matrix(NA,p/2,p/2)
for (j in 1:p/2){
for (k in 1:p/2){
sigma2[j,k] <-  rho2^(abs(j-k))
}
}
x <- cbind(rmvt(n,sigma=sigma1),
rmvnorm(n,mean=rep(0,p/2),sigma=sigma2))
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
e <- rnorm(n,0,1)
y <- x %*% b + e
# CV_rome
cv_rome <- cv.rome(x=x,y=y,FUN="rome.adaptive",delta=0.5)
fit_cv_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=cv_rome$lambda_min,delta=0.5,
adapt=FALSE,trace=FALSE)
# CV_hqreg
cv_hqreg <- cv.hqreg(X=x,y=y,FUN="hqreg_raw",gamma=0.5,intercept=FALSE)
fit_cv_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=c(cv_hqreg$lambda.min,0.9*cv_hqreg$lambda.min),
gamma=0.5,
intercept=FALSE,message=FALSE)
# cv_ILAMM
cv_ILAMM <- cvNcvxHuberReg(X=x,Y=y,tSeq=0.5,nfolds=10,intercept=FALSE, penalty="Lasso")
fit_cv_ILAMM <- ncvxHuberReg(X=x,Y=y,lambda=cv_ILAMM$lambdaMin,
tau=0.5, intercept=FALSE, penalty="Lasso")
c(norm(fit_cv_rome$beta-b,"2")/norm(b,"2"),
norm(fit_cv_hqreg$beta[,1]-b,"2")/norm(b,"2"),
norm(fit_cv_ILAMM$beta[-1]-b,"2")/norm(b,"2"))
# ---------------------------------------------------------- #
# paths:
plot.ts(cbind(mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))),
ylab=c("rome","hqreg","ILAMM"))
data.frame(rome=mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
hqreg=mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
ILAMM=mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2")))
# ---------------------------------------------------------- #
# paths:
plot.ts(data.frame(rome=mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
hqreg=mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
ILAMM=mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))) )
# ---------------------------------------------------------- #
# paths:
plot.ts(data.frame(rome=mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
hqreg=mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
ILAMM=mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))),
main="")
# ---------------------------------------------------------- #
# paths:
plot.ts(data.frame(rome=mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
hqreg=mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
ILAMM=mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))),
main="",xlab="lambda (largest to smallest)")
rm(list=ls())
library("rome")
library("hqreg")
library("ILAMM")
library("mvtnorm")
library("Matrix")
########################################################################
# Data generating process:
n <- 100
p <- 200
# ---------------------------------------------------------- #
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
huber_grad <- function(v, thresh){
if (abs(v) <= thresh){
return(v)
}else{
return(thresh*sign(v))
}
}
########################################################################
# Data generating process:
n <- 100
p <- 200
# ---------------------------------------------------------- #
# type 1:
rho <- 0.8;
sigma = matrix(rho,p,p); diag(sigma) <- 1
x <- rmvnorm(n,mean=rep(0,p),sigma=sigma)
e <- rnorm(n,0,1)
b <- c(2,0,1.5,0,0.8,0,0,1,0,1.75,0,0,0.75,0,0,0.3,rep(0,p-16))
y <- x %*% b + e
########################################################################
# Whole path comparison:
# Set the common threshold and lambda sequences:
gamma <- 0.5
lambda_max <- max(mapply(j=1:p,function(j)abs(sum(mapply(i=1:n,function(i)
huber_grad(y[i],thresh=gamma) * x[i,j]))/n)))/gamma
lambdas <- mapply(j=0:99,function(j)lambda_max*exp((log(0.05)/(100 - 1)))^j)
# ---------------------------------------------------------- #
# rome:
start_t_rome <- proc.time()
fit_rome <- rome.adaptive(y=y,x=x,screen="adaptive",
lambda=lambdas,delta=gamma,
adapt=FALSE)
end_t_rome <- proc.time()
# ---------------------------------------------------------- #
# hqreg:
start_t_hqreg <- proc.time()
fit_hqreg <- hqreg_raw(X=x,y=y,method="huber",
lambda=lambdas/gamma,gamma=gamma,
intercept=FALSE,screen="ASR")
end_t_hqreg <- proc.time()
# ---------------------------------------------------------- #
# ILAMM:
beta_ILAMM <- matrix(NA,p,length(lambdas))
start_t_ILAMM <- proc.time()
for (l in 1:100){
# Fit Huber-SCAD without intercept
fit <- ncvxHuberReg(X=x, Y=y, lambda=lambdas[l], tau=gamma, intercept=FALSE, penalty="Lasso")
beta_ILAMM[,l] <- fit$beta[-1]
# cat(l,"th iteration done.\n")
}
end_t_ILAMM <- proc.time()
# ---------------------------------------------------------- #
# paths:
plot.ts(data.frame(rome=mapply(l=1:100,function(l) norm(fit_rome$beta[,l] - b,"2")/norm(b,"2")),
hqreg=mapply(l=1:100,function(l) norm(fit_hqreg$beta[,l] - b,"2")/norm(b,"2")),
ILAMM=mapply(l=1:100,function(l) norm(beta_ILAMM[,l] - b,"2")/norm(b,"2"))),
main="",xlab="lambda (largest to smallest)")
# time:
c(c(end_t_rome - start_t_rome)[3],
c(end_t_hqreg - start_t_hqreg)[3],
c(end_t_ILAMM - start_t_ILAMM)[3])
getwd()
setwd("D:/High-dimensional time series/Exact coordinate descent/rome")
use_description(fields = list(
Type = "penalized robust M-estimator",
Package = "rome",
Title = "Exact Coordinate Descent for Penalized Robust Regression",
Version = "1.0.0",
`Authors@R` = c(
person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre")),
person("Po-Ling", "Loh", role = "aut"),
person("Sumanta", "Basu", role = "aut")
),
Description = "Performs exact coordinate descent for penalized robust (e.g., Huber loss) regression",
License = "GPL-3",
Depends = "R (>= 4.0.0)",
Imports = "mvtnorm, stats, utils",
LinkingTo = "Rcpp",
Encoding = "UTF-8",
LazyData = "true",
Roxygen = "list(markdown = TRUE)",
RoxygenNote = "7.3.2"
))
library(devtools)
library(roxygen2)
use_description(fields = list(
Type = "penalized robust M-estimator",
Package = "rome",
Title = "Exact Coordinate Descent for Penalized Robust Regression",
Version = "1.0.0",
`Authors@R` = c(
person("Younghoon", "Kim", email = "yk748@cornell.edu", role = c("aut", "cre")),
person("Po-Ling", "Loh", role = "aut"),
person("Sumanta", "Basu", role = "aut")
),
Description = "Performs exact coordinate descent for penalized robust (e.g., Huber loss) regression",
License = "GPL-3",
Depends = "R (>= 4.0.0)",
Imports = "mvtnorm, stats, utils",
LinkingTo = "Rcpp",
Encoding = "UTF-8",
LazyData = "true",
Roxygen = "list(markdown = TRUE)",
RoxygenNote = "7.3.2"
))
document()
load_all()
