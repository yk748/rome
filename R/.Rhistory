library(mvtnorm)
set.seed(123)
n <- 100
p <- 100
x <- rmvnorm(n,mean=rep(0,p),sigma=diag(1,p))
b <- c(runif(2,-10,10),rep(0,p-2))
e <- rnorm(n,0,1)
y <- x %*% b + e
method = c("huber"); weights=NULL;
delta = NULL;
nlambda=100; lambda.min = 0.05; lambda = NULL;
preprocess = c("none");
centering = FALSE;
max.iter = 100; tolerance = 1e-6;
intercept = FALSE;
system("R CMD SHLIB D:/High-dimensional time series/Exact coordinate descent/rome/scr/rome.c")
dyn.load("D:/High-dimensional time series/Exact coordinate descent/rome/scr/rome.dll")
# ------------------------------------------- #
# Include a column for an intercept & weights & threshold
intcpt <- 0
n <- dim(x)[1]
if (intercept == TRUE){
XX <- cbind(rep(1,n), x)
intcpt <- 1
}else{
XX <- x
}
p <- dim(XX)[2]
if (is.null(weights)){
ww <- rep(1,n)
}else{
ww <- weights
}
if (is.null(delta)){
del <- 1.5
}else{
del <- delta
}
# ------------------------------------------- #
# centering
shift <- 0
if (centering == TRUE){
if (method == "huber") {
if(gamma > sd(y)) {
shift <- mean(y)
}else {
shift <- median(y)
}
}
}
yy <- y - shift
# ------------------------------------------- #
# Flag for user-supplied lambdas
user <- 0
if (is.null(lambda)) {
lambda <- double(nlambda)
} else {
nlambda <- length(lambda)
user <- 1
}
# ------------------------------------------- #
# Flags for preprocessing and screening
ppflag <- switch(preprocess, standardize = 1L, rescale = 2L, none = 0L)
# scrflag <- switch(screen, SR = 1L, none = 0L)
fit <- .C("ecd_huber_",
double(p*nlambda),
integer(nlambda),
as.double(lambda),
as.double(XX),
as.double(yy),
as.double(ww),
as.double(del),
as.double(tolerance),
as.double(lambda.min),
as.integer(nlambda),
as.integer(n),
as.integer(p),
as.integer(ppflag),
as.integer(max.iter),
as.integer(user) )
fit <- .C(ecd_huber_,
double(p*nlambda),
integer(nlambda),
as.double(lambda),
as.double(XX),
as.double(yy),
as.double(ww),
as.double(del),
as.double(tolerance),
as.double(lambda.min),
as.integer(nlambda),
as.integer(n),
as.integer(p),
as.integer(ppflag),
as.integer(max.iter),
as.integer(user) )
fit <- .C(ecd_huber_,
double(p*nlambda),
integer(nlambda),
as.double(lambda),
as.double(XX),
as.double(yy),
as.double(ww),
as.double(del),
as.double(tolerance),
as.double(lambda.min),
as.integer(nlambda),
as.integer(n),
as.integer(p),
as.integer(ppflag),
as.integer(max.iter),
as.integer(user) )
fit <- .C(ecd_huber_,
double(p*nlambda),
integer(nlambda),
as.double(lambda),
as.double(XX),
as.double(yy),
as.double(ww),
as.double(del),
as.double(tolerance),
as.double(lambda.min),
as.integer(nlambda),
as.integer(n),
as.integer(p),
as.integer(ppflag),
as.integer(max.iter),
as.integer(user) )
R CMD SHLIB rome.c
dyn.load("rome.dll")
# ------------------------------------------- #
# Needs to be deleted:
dyn.load("D:/High-dimensional time series/Exact coordinate descent/rome/scr/rome.dll")
.C(ecd_huber_,
double(p*nlambda),
integer(nlambda),
as.double(lambda),
as.double(XX),
as.double(yy),
as.double(ww),
as.double(del),
as.double(tolerance),
as.double(lambda.min),
as.integer(nlambda),
as.integer(n),
as.integer(p),
as.integer(ppflag),
as.integer(max.iter),
as.integer(user) )
nm rome.dll
loaded_dlls <- getLoadedDLLs()
if ("rome" %in% names(loaded_dlls)) {
cat("DLL 'rome' is loaded successfully.\n")
} else {
cat("DLL 'rome' is not loaded.\n")
}
if (is.loaded("ecd_huber_")) {
cat("Function 'ecd_huber' is loaded successfully.\n")
} else {
cat("Function 'ecd_huber' is not loaded.\n")
}
if (is.loaded("ecd_huber")) {
cat("Function 'ecd_huber' is loaded successfully.\n")
} else {
cat("Function 'ecd_huber' is not loaded.\n")
}
library(mvtnorm)
set.seed(123)
n <- 100
p <- 100
x <- rmvnorm(n,mean=rep(0,p),sigma=diag(1,p))
b <- c(runif(2,-10,10),rep(0,p-2))
e <- rnorm(n,0,1)
y <- x %*% b + e
method = c("huber"); weights=NULL;
delta = NULL;
nlambda=100; lambda.min = 0.05; lambda = NULL;
preprocess = c("none");
centering = FALSE;
max.iter = 100; tolerance = 1e-6;
intercept = FALSE;
system("R CMD SHLIB D:/High-dimensional time series/Exact coordinate descent/rome/scr/rome.c")
dyn.load("D:/High-dimensional time series/Exact coordinate descent/rome/scr/rome.dll")
if (is.loaded("ecd_huber_")) {
cat("Function 'ecd_huber' is loaded successfully.\n")
} else {
cat("Function 'ecd_huber' is not loaded.\n")
}
